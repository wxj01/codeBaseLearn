面试题：

**java基础的**

```markdown
1.sleep 和 wait 的区别。
主要有四点区别：
	sleep()方法是 Thread 类的静态方法，wait()方法是 Object 超类的成员方法。
	
	sleep()方法导致程序暂停指定的时间，让出 cpu 给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用 sleep()方法的过程中，线程是不会释放锁的。而调用 wait()方法会释放对象锁，只有当此对象调用 notify()方法后才会唤醒线程。
	
	sleep()方法可以在任何地方使用，wait()方法只能在同步方法和同步代码块中配合 synchronized 使用。
	
	sleep()方法需要抛出异常，wait()方法不需要


```



**spring**

~~~makefile
 1.springmvc 页面数据绑定实体原理
 	
~~~







**多线程**

~~~markdown
1.ThreadLocal的理解

2.AQS 的理解

	
~~~





**jvm**

```markdown
1、垃圾回收器有哪些？

​		 新生代收集器：Serial、ParNew、Parallel Scavenge
	
​	     老年代收集器：CMS、Serial Old、Parallel Old

​		 整堆收集器： G1

2、垃圾回收器特点及算法

​	    Serial：单线程，复制算法

​		ParNew：多线程，复制

​		Parallel Scavenge：多线程，吞吐量，复制

​		Serial Old：单线程，标记整理

​		Parallel Old：多线程，标记整理

​		CMS：标记清除

​					初始标记、并发标记、重新标记、并发清除。（初始标记、重新标记会stw)

​					优点：并发收集、低停顿。

​					缺点：浮动垃圾、碎片化

​		G1: 标记整理

​					初始标记、并发标记、最终标记、筛选回收

​					优势：兼顾年轻代和老年代、分区算法不要求空间连续、减少碎片化、可预见性

3、排查内存泄漏/溢出问题？

    1.jps 找到id

    2.jstack 看是不是栈有没有异常

    2.jstat 查看内存和垃圾回收情况

    3.jmap 生成内存快照，可以配置参数HeapDumpOnOutOfMemoryError，自动导出

    4.导入Java visualMv 

4、OOM都有哪些及导致的原因

    1.堆溢出：Java heap space   ；大对象、内存泄漏

    2.永久代/元空间溢出：PermGen space ，Metaspace；String.intern()、大量的代理类

    3.频繁回收：GC overhead limit exceeded；堆太小

    4.大量线程创建：unable to create new native Thread；

    5.swap溢出：Out of swap space；swap不足、其他进程消耗内存

    6.本地方法溢出:stack_trace_with_native_method;内存分配失败

5、什么是双亲委派机制
	
	一个类加载器收到类的请求，不会自己加载，而是把类给父加载器，每一层加载器都是如此，所有的加载请
求最终传到顶层启动类加载器，只有父类加载器无法完成加载，子加载器才会去加载。

6、双亲委派机制的作用
	1.防止重复加载同一个.class
	2.保证核心的.class 不能被篡改
	
7、如何打破双亲委派 
	1.重写loadClass()方法；
	2.ThreadContextClassLoader 的 setContextClassLoader指定
	3.热部署和热启动：idea 、tomcat。原理重写ClassLoader.loaderClass方法

8、类的加载时机（什么情况开始类加载过程）
	1.遇到new 、getstatic、 putstatic、invokestatic
	2.反射，类没有初始化线触发初始化
	3.父类没有初始化
	4.虚拟机启动，执行主类（包含main()的那个类）
	5.动态语言的MethodHandle实例解析REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄对应的类初始化
    6.default修饰的接口，实现类发生初始化之前接口先初始化

9、类加载过程（加载、验证、准备、解析、初始化、使用、卸载）
	1.加载：
		类到二进制字节流，静态结构转运行时结构，生成类的Class对象
	2.验证：
		文件格式验证、元数据验证、字节码验证、符号引用验证
    3.准备：
    	类的静态变量分配内存并设置类变量的初始值
    4.解析：
    	常量池符号引用变直接引用
    5.初始化
    	执行类构造器<clinit()>的过程
    6.使用
    7.卸载
    
10、java new 一个对象的过程，jvm 发生了什么。
	1.虚拟机遇到new，在常量池中能否定位到一个类的符号引用，有则用，没有执行类加载
	2.分配内存
		指针碰撞：内存规整，指针作为分界点，分配内存指针移动一段空闲空间给对象
		空闲列表：内存不规整，维护空闲列表记录哪些内存块可用，分配从列表中找一个给对象
	3.数据类型初始化为零值（不包括对象头）
	4.对象头设置：所属类、元数据信息、哈希吗、GC分代年龄、锁等相关信息
	5.调用对象的init()方法
	6.在线程栈中新建对象引用，并指向堆中刚刚新建的对象实例
	
11、垃圾回收的过程

		
12、GCRoot 有哪些？
	1.栈（栈帧中的本地变量表）中引用的对象
	2.方法区中类静态属性引用的对象
	3.方法区中常量引用的对象
	4.本地方法栈中JNI引用的对象

13.CMS 和 G1 的区别
	1.使用范围
		CMS 老年代 可以配合新生代的serial和ParNew收集器
		G1 老年代和新生代。不需要其他收集器配合
	2.STW的时间
    	CMS 收集器以最小单位停顿时间为目标的收集器
    	G1  可以预测垃圾回收的停顿时间（简历可预测的停顿时间模型）
	3.垃圾碎片
		CMS  标记清除 有垃圾碎片
		G1   标记整理 降低内存空间碎片
	4.垃圾回收过程
    	CMS 初始标记 并发标记 重新标记 并发清理
    	G1  初始标记 并发标记 最终标记 筛选回收
    5.大对象的处理
    	CMS 对象过大，进入S1、S2区域时大于该分配区域，直接进入老年代
    	G1  判断大对象是否大于一个Region大小的 50%,大于50%就会横跨多个Region进行存放
```



**redis**

```markdown
1、常用的数据类型
	1.String : SDS
	2.list : ziplist、linkedlist
	3.hash : ziplist、 hashtable
	4.set：  inset 、 hashtable
	5.zset:  ziplist、skiplist
	
2、hash 是怎么扩容的（rehash，分而治之思想）
	1.为ht[1]分配空间、让字典同时持有ht[0] 和 ht[1];
	2.将rehashindex 的值置为 0 ，表示rehash 开始
	3.rehash期间，每次对字典执行增删改查操作，还会将ht[0]哈希表的rehashindex索引上所有键值对	rehash到ht[1],当rehash完成后，rehashindex的值 +1
	4.ht[0]上所有键值对rehash 到 ht[1] 后，rehashindex 的值 置为 -1
	
	注意的是在渐进式rehash的过程，如果有增删改查操作时，如果index大于rehashindex，访问		ht[0]，否则访问ht[1]
	
3、
```



**mysql**

~~~markdown
1.深度分页及优化问题
		select * from table limit 3000000,10;
	比如你要查询 300w开始后面10条数据；mysql会读取300w加10条这么多的数据，只不过 过滤后返回最后10条而已！！！
	
	解决办法：
	第一种简单粗暴，就是不允许查看这么靠后的数据。
	第二种方法，在查询下一页时把上一页的行id作为参数传递给客户端程序，然后sql就改成了
		select * from table where id>3000000 limit 10;
	第三种方法：延迟关联
    	select id from table limit 3000000,10;

		你会发现时间缩短了一半；然后我们在拿id分别去取10条数据就行了；

		语句就改成这样了：

		select table.* from table inner join ( select id from table limit 3000000,10 ) as 		  tmp on tmp.id=table.id;
	第四种方法：Elastic Search搜索引擎优化

2.mysql几种日志及作用
	
    1：重做日志（redo log）
    	确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防		止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的	  持久性这一特性。

    2：回滚日志（undo log）
    	保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读	  （MVCC），也即非锁定读

    3：二进制日志（binlog）
    	用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还			原。

    4：错误日志（errorlog）
    	错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错		误日志的功能是关闭的，错误信息被输出到标准错误输出。

    5：慢查询日志（slow query log）
    	记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general 		log 都会将其记录下来 ，记录的格式为 {Time ，Id ，Command，Argument }。也正因为mysql服务器需要		不断地记录日志，开启General log会产生不小的系统开销。

    6：一般查询日志（general log）
    	慢日志记录执行时间过长和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日			志只会记录执行成功的语句。

    7：中继日志（relay log）
    	从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后从服务器SQL线程会读取			relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致
~~~



**Elasticsearch**

~~~markdown
1.倒排索引的原理
	
~~~



**计算机网络**

~~~markdown
1.http 请求流程（类似浏览器输入url 发生了什么）

	1.URL 解析
		URL合法、HSTS强制使用HTTPS、检查缓存
	2.DNS 查询
		浏览器缓存、操作系统缓存、路由器缓存、DNS缓存、根域名服务器
	3.TCP 链接
		应用层、传输层、网路层、链路层。三次握手
	4.浏览器发起Http请求
		建立Tcp连接后，发起HTTP请求（方法、请求头、请求正文）
	5.处理请求
		解析用户的请求、调度资源文件、数据，将结果返回浏览器
	6.关闭Tcp 连接
		避免资源占用和损耗，无响应时，通过4次握手关闭
	7.浏览器解析资源及渲染
		HTML、CSS、JS、图片 解析DOM 树 CSS规则树
~~~





**开放题**

```markdown
1、生产服务器变慢
	1.top
	
	2.cpu:vmstat;查看所以cpu核信息 mpstat -p ALL 2;进程使用cpu信息 pidstat -u 1 -p 进			 程号
	
	3.内存：free
	
	4.硬盘：df
	
	5.磁盘：iostat
	
	6.网络：ifstat
	
2.接口相应时间长，如何降低200ms 内？
	常见的原因：
		1. 慢SQL 导致性能，主要没有命中索引
		2. 发送远程数据请求（RPC 远程调用、HTTP 远程调用）
		3. I/O 操作
		4. 循环中执行SQL或网络请求、
	解决：
    	1.尽量减少请求，请求串行改成多线程/并发
    	2.接口拆分
    		垂直拆分：大而复杂的服务拆分成多个相互独立，职能单一的服务，单独部署
    		水平拆分：水平拆分可以简单理解成mapreduce模型，把整个计算逻辑或者数据平均分配到集群中的N个服						务器去，然后由一台机器去并发调用并做结果合并
    	3.缓存
        	接口缓存：结果缓存，采用“哨兵”的分布式缓存设计
        	本地缓存：
        			1).类似字典类型的数据，可以静态化后放入内存，定时去刷新或者采用通知机制去更新；
        			2).ThreadLocal缓存重复内部计算与重复的对象创建，对于链路比较长或者循环比较深的接						   口，ThreadLocal减少重复计算和对象创建，从而降低RT和节约内存
        4.内部优化
        	非核心流程异步化（MQ）：类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采								用异步方式进行处理，不阻塞主计算逻辑处理
        	内部并发：并发调用IO较大，可以考虑换成内部并发解决IO问题,多线程处理，可调整线程数
	    5.数据库优化（这个单独总结）
	    	索引：尽量走索引，避免全表，回表。
	    	关键字：distinct,count 尽可能少用
	    6.锁
	    	单机锁和分布式锁，锁其实我们能够避免就不要使用它，因为加锁就代表只能串行执行，并发数降为1	。
	    	
3.秒杀系统设计	    	
        	
```



**项目总结**

~~~markdown
1.项目中的亮点
	1.黑名单的权限控制：
		采用自定义注解+AOP进行方法的访问权限控制，将配置的ip和对应的接口方法从表中查出加入缓存，根据自定义的注解，通过AOP去获取方法，判断访问的ip在缓存中是否存在来控制接口非访问权限，达到黑名单的效果

2.项目中需要改进的点
	1.代码规范
	2.代码注释


~~~



**我的思考**

~~~makefile
1.项目中出现一堆if else 如何优雅的处理：
2.SQL的有待提高	
3.tomcat中的catalina.out 文件会越来越大
4.
~~~

