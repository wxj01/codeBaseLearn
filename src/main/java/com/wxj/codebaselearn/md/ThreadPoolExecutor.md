为什么使用线程池,优势?
线程池做的工作主要是控制运行的线程的数量,处理过程中将任务加入队列,
然后在线程创建后启动这些任务,如果线程超过了最大数量,超出的数量的线程排队等候,等其他线程执行完毕,再从队列中取出任务来执行.
他的主要特点为:线程复用;控制最大并发数;管理线程.
第一: 降低资源消耗.通过重复利用自己创建的线程降低线程创建和销毁造成的消耗.
第二: 提高响应速度.当任务到达时,任务可以不需要等到线程创建，就能立即执行.
第三: 提高线程的可管理性.线程是稀缺资源,如果无限的创建,不仅会消耗资源,还会较低系统的稳定性,使用线程池可以进行统一分配,调优和监控.



Executors.newFixedThreadPool(int); 执行一个长期的任务,性能好很多
Executors.newSingleThreadExecutor(); 一个任务一个线程执行的任务场景
Executors.newCachedThreadPool();适用:执行很多短期异步的小程序或者负载较轻的服务器

ThreadPoolExecutor底层是什么？
1.corePoolSize:线程池中的常驻核心线程数.
    a.在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,类比为今日当值线程
    b.当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中.

2.maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1.

3.keepAliveTime:多余的空闲线程存活时间,当空间时间达到keepAliveTime值时,多余的线程会被销毁直到只剩下corePoolSize个线程为止.
    a.默认情况下:只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,知道线程中的线程数不大于corePoolSize

4.unit:keepAliveTime的单位

5.workQueue:任务队列,被提交但尚未被执行的任务.

6.threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可

7.handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大显示数(maximumPoolSize)时如何来拒绝.


说说线程池的底层工作原理?
1.在创建了线程后，等待提交过来的任务请求.
2.当调用execute()方法添加一个请求任务时，线程池会做如下判断：
    a.如果正在运行的线程数量小于corePoolSize,那马上创建线程执行请求任务
    b.如果正在运行的线程数量大于corePoolSize,那么这个任务加入队列中
    c.如果队列满了且正在运行的线程数量小于maximumPoolSize,开始创建非核心线程执行请求任务
    d.如果队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会启动饱和拒绝策略来执行
3.当一个线程完成任务时，该线程会从队列中取 下一个任务来执行
4.当一个线程无事可做且超过一定时间（keepAliveTime）时，线程池会开始判断：
    a.如果当前运行的线程数大于corePoolSize,那么这个线程就会被停掉


线程池的拒绝策略请你谈谈？
等待队列也已经排满了,再也塞不下新的任务了 同时, 线程池的max也到达了,无法接续为新任务服务 这时我们需要拒绝策略机制合理处理这个问题.

JDK内置的拒绝策略
1.AbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行.
2.CallerRunPolicy:"调用者运行"一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者，从而降低新任务的流量.
3.DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交.
4.DiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好拒绝策略.


你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑
答案是一个都不用,我们生产上只能使用自定义的

Executors中JDK给你提供了为什么不用?
参考阿里巴巴java开发手册
【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：Executors返回的线程池对象的弊端如下：
1）FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。
2）CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。


合理配置线程池你是如何考虑的?
1.CPU密集型 ：例子计算
    一般公式：CPU核数+1个线程的线程池
2.IO密集型：例子 数据库数据的交互，文件上传下载，网络数据传输
    a.由于密集型任务线程不是一直执行，应配置尽可能多的线程，CPU核数*2
    b.IO密集型，大部分线程都会阻塞，一般公式：CPU/1-阻塞系数   阻塞系数 0.8~0.9  
    